import org.unbrokendome.gradle.plugins.helm.command.tasks.*

plugins{
    id "base"
    id "nl.eleven.node-gradle.node" version "1.0.0"
    id "org.unbroken-dome.gitversion" version "0.10.0"
    id 'org.unbroken-dome.helm' version '1.5.0'
    id 'org.unbroken-dome.helm-commands' version '1.5.0'
    id 'org.unbroken-dome.helm-publish' version '1.5.0'
    id 'org.unbroken-dome.helm-releases' version '1.5.0'
    id "com.google.osdetector" version "1.7.0"
    id "com.github.rmee.kubectl" version "1.1.20200614081240"
    id "com.github.rmee.gcloud" version "1.1.20200614081240"
    id "com.palantir.docker" version "0.28.0"
    id "com.palantir.docker-run" version "0.28.0"
}


var nodeVersion = "16.8.0"

var projectId = System.getenv("PROJECT_ID")
var clusterZone  = System.getenv("API_ZONE")
var clusterName = System.getenv("API_CLUSTER")
var jwtKey = System.getenv("JWT_KEY")
var jwtRefreshKey = System.getenv("JWT_REFRESH_KEY")
var mongoIp = System.getenv("MONGO_IP")
var cuClientKey = System.getenv("CU_CLIENT_KEY")
var cuSecretKey = System.getenv("CU_SECRET_KEY")
var cuRedirectUri = System.getenv("CU_REDIRECT_URI")
var cuJwtKey = System.getenv("CU_JWT_KEY")



gitVersion{
    rules{
        baseVersion = "1.0.0"

        onBranch(~/feature\/(.+)/) {
            def lastTag = findLatestTag ~/v?(\d+)\.(\d+)/

            if(lastTag){
                version.mayor = lastTag.mayor
                version.minor = lastTag.minor
                version.patch = lastTag.minor
            }

            version.prereleaseTag = matches[1]
        }
    }
}

//Aca se usa la version.
version = gitVersion.determineVersion()
String imageId = "gcr.io/$projectId/$project.name:$project.version"

helm {

    namespace = "cl-dssa-api"

    downloadClient {
        enabled = true
        version = "3.6.3"
    }

    charts {
        api {
            chartName = "$project.name"
            version = "$project.version"
            sourceDir = file("$projectDir/helm/$project.name")
        }
    }

    releases {
        "api-login-clave-unica" {
            from charts.api

            forTarget('local') {
                values.put('secrets.jwtKey', jwtKey)
                values.put('secrets.jwtRefreshKey', jwtRefreshKey)
                values.put('secrets.mongoUrl', "mongodb://$mongoIp:27017/hrapp_dev")
                values.put('secrets.cuClientKey', cuClientKey)
                values.put('secrets.cuSecretKey', cuSecretKey)
                values.put('secrets.cuRedirectUri', cuRedirectUri)
                values.put('secrets.cuJwtKey', cuJwtKey)
            }

            forTarget('staging') {
                values.put('secrets.jwtKey', jwtKey)
                values.put('secrets.jwtRefreshKey', jwtRefreshKey)
                values.put('secrets.mongoUrl', "mongodb://$mongoIp:27017/hrapp")
                values.put('secrets.cuClientKey', cuClientKey)
                values.put('secrets.cuSecretKey', cuSecretKey)
                values.put('secrets.cuRedirectUri', cuRedirectUri)
                values.put('secrets.cuJwtKey', cuJwtKey)
            }

            forTarget('production'){
                values.put('secrets.jwtKey', jwtKey)
                values.put('secrets.jwtRefreshKey', jwtRefreshKey)
                values.put('secrets.mongoUrl', "mongodb://$mongoIp:27017/hrapp")
                values.put('secrets.cuClientKey', cuClientKey)
                values.put('secrets.cuSecretKey', cuSecretKey)
                values.put('secrets.cuRedirectUri', cuRedirectUri)
                values.put('secrets.cuJwtKey', cuJwtKey)
            }

            forAnyTarget{
                values.put('image.tag', project.version)
            }
        }
    }

    releaseTargets{
        local {
            kubeContext = "kind-kind"
        }

        staging {
            kubeContext = "gke_${projectId}_${clusterZone}_${clusterName}"
        }

        production {
            kubeContext = "gke_${projectId}_${clusterZone}_${clusterName}"
        }
    }
}


node {
    download true
    version nodeVersion
}


docker {
    name imageId
    files fileTree("$project.buildDir/node")
}

dockerRun {
    name  "mongo"
    image "mongo:5.0"
    ports  "27017:27017"
    daemonize true
    ignoreExitValue true
}

String testsExecutedMarkerName = "${projectDir}/.tests.executed"
String runningMongo = "${projectDir}/.tests.mongo"

tasks.named("dockerRemoveContainer"){t-> t.dependsOn(dockerStop)}

tasks.named("dockerRun"){t->
    {
        t.doLast {
            new File(runningMongo).text = "Running mongo"
        }
        t.outputs.file runningMongo
    }
}

task startMongo {
    dependsOn "dockerRun"
}

task stopMongo {
    dependsOn dockerRemoveContainer

    doLast {
        delete runningMongo
    }
}


task testApi(type: NpmTask) {
    dependsOn npmInstall, startMongo
    environment CI: 'true'

    args = ['run', 'test', '--ci']

    inputs.files fileTree('api')
    inputs.files fileTree('test')
    inputs.file 'package.json'
    inputs.file 'package-lock.json'

    doLast {
        new File(testsExecutedMarkerName).text = 'delete this file to force re-execution JavaScript tests'
    }

    outputs.file testsExecutedMarkerName
}

task apiBuild(type: NodeTask) {
    inputs.files fileTree('api')

    script = file("build.js")
    args = [ "$project.projectDir/api/app.js","$project.buildDir/node"]

    outputs.file "$project.buildDir/node/app.js"
}

task gcrLogin(type:Exec){
    commandLine "docker", "login", "-u", "_json_key", "--password-stdin", "https://gcr.io"
    standardInput new BufferedInputStream(new FileInputStream("key.json"))
}

dockerfileZip.dependsOn testApi
apiBuild.dependsOn testApi
dockerPrepare.dependsOn apiBuild
tasks.named("docker").get().dependsOn testApi, apiBuild
assemble.dependsOn "docker"
clean.dependsOn stopMongo
dockerPush.dependsOn build, gcrLogin

gcloud {
    cli {
        imageName = 'google/cloud-sdk'
        imageTag = '352.0.0'
    }

    keyFile = file("$projectDir/key.json")
    zone = clusterZone
    project = "saludantofagasta-proy1"

    gke {
        clusterName = clusterName
    }
}

gcloudSetProject.dependsOn gcloudActivateServiceAccount
gcloudGetKubernetesCredentials.dependsOn gcloudSetProject

task createNamespace(type:Exec){
    commandLine 'kubectl', 'create','namespace','cl-dssa-api'
    ignoreExitValue true
}

helmInstallApiLoginClaveUnicaToLocal.dependsOn dockerPush, createNamespace
helmInstallApiLoginClaveUnicaToStaging.dependsOn dockerPush, gcloudGetKubernetesCredentials
helmInstallApiLoginClaveUnicaToProduction.dependsOn dockerPush, gcloudGetKubernetesCredentials


clean {
    delete testsExecutedMarkerName
}

task printVersion {
    doLast { println project.version }
}
